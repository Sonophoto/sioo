#include "soarapi.h"
#include "soar_core_api.h"
#include "soarkernel.h"
#include "parsing.h"
#include "soarInterfaceCommands.h"
#include "ask.h"
#include <stdio.h>


#ifdef ADD_TCL_RHS_STUB

Symbol *tcl_rhs_function_stub ( list *args ) {	return NIL; }

#endif /* ADD_TCL_RHS_STUB */


void runEachAgentOnce() {
  soar_apiAgentIterator ai;	

  printf( "\n\n\n  ------- Iterating -------  \n\n\n" );
  soar_cInitAgentIterator( &ai ); 
  do {
	  printf( "\n\nrunning 1...\n" );	  
	  soar_cRun( 1, 0, GO_DECISION, NO_SLOT );
  } while ( soar_cStepAgentIterator( &ai ) );
	
}


/*
 *  This funtion is registered with the Soar kernel and called when
 *  Soar generates output.  
 */
void cb_multiagent_print ( agent *the_agent, soar_callback_data d,	soar_call_data c ) {
  
	printf( "%s: %s", the_agent->name, (char *)c );
}


/*****************************************************************************
 *
 * The main routine for the shell interface to Soar.
 *
 *****************************************************************************/

int main( int argc, char **argv ) {

  agent *a;
  int i;
  char *names[] = {"AgentA", "AgentB", "AgentC"};


  /*
   *  Initialize Soar, this must be called once (and only once) before
   *  any of Soar's functionality is used.  It basically allocates 
   *  memory and initializes some of Soar's internal data structures
   */
  soar_cInitializeSoar();
  
  for( i = 0; i < 3; i++ ) {
	  /* 
	   * Create an agent.  In this example we will only have one agent,
	   *  although more are certainly possible
	   */
	  soar_cCreateAgent( names[i] );
	  a = soar_cGetAgentByName( names[i] );
	  
	  /*
	   *  Register a function (defined by us) which will handle the output
	   *  generated by the kernel.  Most (if not all) interfaces need to
	   *  register some type of callback to deal with print calls.  In the
	   *  future, it will be easier to avoid this step in the special
	   *  circumstances where it is a burden 
	   */
	  soar_cPushCallback( a, PRINT_CALLBACK, (soar_callback_fn) cb_multiagent_print,
						  NULL, NULL );

  
	  /*
	   *  Register a function to handle clean up when Soar is terminated.
	   *  This is mainly for illustrative purposes.
	   */
	  soar_cPushCallback( a, SYSTEM_TERMINATION_CALLBACK, 
		      (soar_callback_fn) cb_exit, NULL, NULL );

	  soar_cPushCallback( a, ASK_CALLBACK, 
						  (soar_callback_fn) askCallback, NULL, NULL);

	  printf( "Initialized %s...\n", names[i] );
  }

  /** 
   * for this test, we will just be examining the list of agents, and
   * modifying its structure by deleting agents... after each operation
   * we iterate through the agent list and run each agent 1 cycle, just to 
   * show they still work...
   */
  runEachAgentOnce();
 
  printf( "\n\nDeleting agent B\n" );
  soar_cDestroyAllAgentsWithName( "AgentB" );
  runEachAgentOnce();


  printf( "\n\nDeleting agent B again\n" );
  soar_cDestroyAllAgentsWithName( "AgentB" );
  runEachAgentOnce();  

  a = soar_cGetAgentByName( "AgentC" );
  printf( "\n\nDestroying agent at head of list!\n");
  soar_cDestroyAgentByAddress( a );
  runEachAgentOnce();
  printf( "\nDone.\n" );
  return 0;
}





